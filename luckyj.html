<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Lucky Jett</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <base href="https://xlaswad.github.io/telegram-webapp222">
    <link rel="stylesheet" href="luckyjett/luckyj.css">
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
</head>
<body>

<!-- Кнопка "Назад" -->
<a href="/mainpage/index.html" class="back-button" title="Назад">
    <svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 24 24" fill="none">
        <circle cx="12" cy="12" r="12" fill="#3A4750"/>
        <path d="M12 8 L8 12 L12 16" stroke="white" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round" fill="none"/>
        <path d="M16 12 H8" stroke="white" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round" fill="none"/>
    </svg>
</a>

<!-- Игровая зона -->
<div class="game-area">
    <div class="sky">
        <div id="plane" class="plane">✈</div>
    </div>

    <div class="hud">
        <!-- Множитель -->
        <div id="multiplier" class="multiplier">0.00X</div>

        <!-- Отсчёт между раундами -->
        <div id="cooldown" class="cooldown"></div>
    </div>
</div>

<script>
    // Telegram WebApp Init (безопасный вызов)
    try {
        const tg = window.Telegram.WebApp;
        tg.expand && tg.expand();
    } catch (e) { /* ignore */ }

    // Функция генерации множителя (как в твоём коде)
    function generateMultiplier() {
        const multiplierElement = document.getElementById('multiplier');
        const randomValue = (Math.random() * 2 + 1).toFixed(2);
        multiplierElement.textContent = randomValue + "X";
        return parseFloat(randomValue); // возвращаем число
    }

    // Анимация числа от 0 до target за duration (ms)
    function animateNumberTo(element, target, duration) {
        return new Promise((resolve) => {
            const start = performance.now();
            const startValue = 0;
            function easeOutQuad(t) { return t*(2-t); }

            function step(now) {
                const elapsed = now - start;
                const progress = Math.min(elapsed / duration, 1);
                const eased = easeOutQuad(progress);
                const current = startValue + (target - startValue) * eased;
                element.textContent = current.toFixed(2) + "X";

                if (progress < 1) {
                    requestAnimationFrame(step);
                } else {
                    element.textContent = target.toFixed(2) + "X";
                    resolve();
                }
            }
            requestAnimationFrame(step);
        });
    }

    let cycleRunning = false;

    async function startRound() {
        if (cycleRunning) return;
        cycleRunning = true;

        const multiplierEl = document.getElementById('multiplier');
        const plane = document.getElementById('plane');
        const cooldownEl = document.getElementById('cooldown');

        // Генерация множителя
        const target = generateMultiplier();
        multiplierEl.textContent = "0.00X"; // сбрасываем для анимации
        cooldownEl.textContent = "";

        // Длительность полёта / анимации
        const flightDuration = 5000; // 5 секунд
        plane.style.setProperty('--flight-duration', (flightDuration/1000) + 's');

        // сброс состояния
        plane.classList.remove('fly');
        void plane.offsetWidth; // сброс анимации

        // параллельная анимация числа и полёта
        const numberPromise = animateNumberTo(multiplierEl, target, flightDuration);
        const planePromise = new Promise((resolve) => {
            function onAnimEnd() {
                plane.removeEventListener('animationend', onAnimEnd);
                resolve();
            }
            plane.addEventListener('animationend', onAnimEnd);
            plane.classList.add('fly');
        });

        await Promise.all([numberPromise, planePromise]);

        multiplierEl.textContent = target.toFixed(2) + "X";

        // отсчёт 15 секунд
        let remaining = 15;
        cooldownEl.textContent = "Следующий запуск через " + remaining + "s";

        const cdInterval = setInterval(() => {
            remaining -= 1;
            if (remaining <= 0) {
                clearInterval(cdInterval);
                cooldownEl.textContent = "";
                cycleRunning = false;
                startRound(); // следующий раунд
            } else {
                cooldownEl.textContent = "Следующий запуск через " + remaining + "s";
            }
        }, 1000);
    }

    // старт сразу при загрузке
    startRound();
</script>

</body>
</html>
